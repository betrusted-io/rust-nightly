From 7880a8b8e029709dda0e2f2c10584d4266dd99fb Mon Sep 17 00:00:00 2001
From: Sean Cross <sean@xobs.io>
Date: Tue, 7 Nov 2023 10:41:10 +0800
Subject: [PATCH 3/4] xous: fs: add initial filesystem support

Signed-off-by: Sean Cross <sean@xobs.io>
---
 library/std/src/os/xous/fs.rs            |  33 ++
 library/std/src/os/xous/mod.rs           |   3 +
 library/std/src/os/xous/path.rs          |  42 ++
 library/std/src/os/xous/services.rs      |   3 +
 library/std/src/os/xous/services/pddb.rs |  88 ++++
 library/std/src/sys/pal/xous/fs.rs       | 629 +++++++++++++++++++++++
 library/std/src/sys/pal/xous/mod.rs      |   1 -
 7 files changed, 798 insertions(+), 1 deletion(-)
 create mode 100644 library/std/src/os/xous/fs.rs
 create mode 100644 library/std/src/os/xous/path.rs
 create mode 100644 library/std/src/os/xous/services/pddb.rs
 create mode 100644 library/std/src/sys/pal/xous/fs.rs

diff --git a/library/std/src/os/xous/fs.rs b/library/std/src/os/xous/fs.rs
new file mode 100644
index 00000000000..cd19095bd0c
--- /dev/null
+++ b/library/std/src/os/xous/fs.rs
@@ -0,0 +1,33 @@
+#![stable(feature = "rust1", since = "1.0.0")]
+
+use crate::fs;
+use crate::sys_common::AsInner;
+
+#[stable(feature = "file_type_ext", since = "1.5.0")]
+pub trait FileTypeExt {
+    /// Returns `true` if this file type is a basis.
+    ///
+    /// # Examples
+    ///
+    /// ```no_run
+    /// use std::fs;
+    /// use std::os::xous::fs::FileTypeExt;
+    /// use std::io;
+    ///
+    /// fn main() -> io::Result<()> {
+    ///     let meta = fs::metadata(":.System")?;
+    ///     let file_type = meta.file_type();
+    ///     assert!(file_type.is_basis());
+    ///     Ok(())
+    /// }
+    /// ```
+    #[stable(feature = "file_type_ext", since = "1.5.0")]
+    fn is_basis(&self) -> bool;
+}
+
+#[stable(feature = "file_type_ext", since = "1.5.0")]
+impl FileTypeExt for fs::FileType {
+    fn is_basis(&self) -> bool {
+        self.as_inner().is_basis()
+    }
+}
diff --git a/library/std/src/os/xous/mod.rs b/library/std/src/os/xous/mod.rs
index 4b21695c4ac..644327ac514 100644
--- a/library/std/src/os/xous/mod.rs
+++ b/library/std/src/os/xous/mod.rs
@@ -7,6 +7,9 @@
 #[stable(feature = "rust1", since = "1.0.0")]
 pub mod services;
 
+pub mod fs;
+pub mod path;
+
 /// A prelude for conveniently writing platform-specific code.
 ///
 /// Includes all extension traits, and some important type definitions.
diff --git a/library/std/src/os/xous/path.rs b/library/std/src/os/xous/path.rs
new file mode 100644
index 00000000000..c601ff8f1a2
--- /dev/null
+++ b/library/std/src/os/xous/path.rs
@@ -0,0 +1,42 @@
+#![stable(feature = "rust1", since = "1.0.0")]
+
+use crate::path;
+
+#[stable(feature = "file_type_ext", since = "1.5.0")]
+pub trait PathExt {
+    /// Returns `true` if this file type is a basis.
+    ///
+    /// # Examples
+    ///
+    /// ```no_run
+    /// use std::fs;
+    /// use std::os::xous::fs::FileTypeExt;
+    /// use std::io;
+    ///
+    /// fn main() -> io::Result<()> {
+    ///     let meta = fs::metadata(":.System")?;
+    ///     let file_type = meta.file_type();
+    ///     assert!(file_type.is_basis());
+    ///     Ok(())
+    /// }
+    /// ```
+    #[stable(feature = "file_type_ext", since = "1.5.0")]
+    fn is_basis(&self) -> bool;
+}
+
+#[stable(feature = "file_type_ext", since = "1.5.0")]
+impl PathExt for path::Path {
+    fn is_basis(&self) -> bool {
+        let as_str = match self.as_os_str().to_str() {
+            Some(o) => o,
+            None => return false,
+        };
+
+        let (basis, path) = match crate::sys::path::split_basis_and_dict(as_str, || Some("")) {
+            Ok(o) => o,
+            Err(_) => return false,
+        };
+
+        basis.is_some() && path.is_none()
+    }
+}
diff --git a/library/std/src/os/xous/services.rs b/library/std/src/os/xous/services.rs
index 93916750c05..bfdc1377fd6 100644
--- a/library/std/src/os/xous/services.rs
+++ b/library/std/src/os/xous/services.rs
@@ -11,6 +11,9 @@
 mod net;
 pub(crate) use net::*;
 
+mod pddb;
+pub(crate) use pddb::*;
+
 mod systime;
 pub(crate) use systime::*;
 
diff --git a/library/std/src/os/xous/services/pddb.rs b/library/std/src/os/xous/services/pddb.rs
new file mode 100644
index 00000000000..f8459b5bac9
--- /dev/null
+++ b/library/std/src/os/xous/services/pddb.rs
@@ -0,0 +1,88 @@
+use crate::io::SeekFrom;
+use crate::os::xous::ffi::Connection;
+use crate::os::xous::services::connect;
+use core::sync::atomic::{AtomicU32, Ordering};
+
+#[repr(usize)]
+pub(crate) enum PddbBlockingScalar {
+    SeekKeyStd(u16 /* fd */, SeekFrom),
+    CloseKeyStd(u16 /* fd */),
+}
+
+#[repr(usize)]
+pub(crate) enum PddbLendMut {
+    OpenKeyStd,
+    ReadKeyStd(u16 /* fd */),
+    DeleteKeyStd = 35,
+    ListPathStd = 37,
+    StatPathStd = 38,
+
+    /// Create a dict
+    CreateDictStd,
+
+    /// Remove an empty dict
+    DeleteDictStd,
+}
+
+#[repr(usize)]
+pub(crate) enum PddbLend {
+    WriteKeyStd(u16 /* fd */),
+}
+
+impl Into<usize> for PddbLendMut {
+    fn into(self) -> usize {
+        match self {
+            PddbLendMut::OpenKeyStd => 30,
+            PddbLendMut::ReadKeyStd(fd) => 31 | ((fd as usize) << 16),
+            PddbLendMut::DeleteKeyStd => 35,
+            PddbLendMut::ListPathStd => 37,
+            PddbLendMut::StatPathStd => 38,
+            PddbLendMut::CreateDictStd => 40,
+            PddbLendMut::DeleteDictStd => 41,
+        }
+    }
+}
+
+impl Into<usize> for PddbLend {
+    fn into(self) -> usize {
+        match self {
+            PddbLend::WriteKeyStd(fd) => 32 | ((fd as usize) << 16),
+        }
+    }
+}
+
+impl<'a> Into<[usize; 5]> for PddbBlockingScalar {
+    fn into(self) -> [usize; 5] {
+        match self {
+            PddbBlockingScalar::SeekKeyStd(fd, from) => {
+                let (a1, a2, a3) = match from {
+                    SeekFrom::Start(off) => {
+                        (0, (off as usize & 0xffff_ffff), ((off >> 32) as usize) & 0xffff_ffff)
+                    }
+                    SeekFrom::Current(off) => {
+                        (1, (off as usize & 0xffff_ffff), ((off >> 32) as usize) & 0xffff_ffff)
+                    }
+                    SeekFrom::End(off) => {
+                        (2, (off as usize & 0xffff_ffff), ((off >> 32) as usize) & 0xffff_ffff)
+                    }
+                };
+                [39 | ((fd as usize) << 16), a1, a2, a3, 0]
+            }
+            PddbBlockingScalar::CloseKeyStd(fd) => [34 | ((fd as usize) << 16), 0, 0, 0, 0],
+        }
+    }
+}
+
+/// Return a `Connection` to the PDDB database server. This server is used for
+/// communicating with the persistent database.
+pub(crate) fn pddb_server() -> Connection {
+    static PDDB_CONNECTION: AtomicU32 = AtomicU32::new(0);
+    let cid = PDDB_CONNECTION.load(Ordering::Relaxed);
+    if cid != 0 {
+        return cid.into();
+    }
+
+    let cid = connect("_Plausibly Deniable Database_").unwrap();
+    PDDB_CONNECTION.store(cid.into(), Ordering::Relaxed);
+    cid
+}
diff --git a/library/std/src/sys/pal/xous/fs.rs b/library/std/src/sys/pal/xous/fs.rs
new file mode 100644
index 00000000000..fb2182e2091
--- /dev/null
+++ b/library/std/src/sys/pal/xous/fs.rs
@@ -0,0 +1,629 @@
+use alloc::str::FromStr;
+
+use crate::ffi::OsString;
+use crate::fmt;
+use crate::hash::Hash;
+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};
+use crate::os::xous::ffi::{blocking_scalar, lend_mut, OsStrExt};
+use crate::os::xous::services::{pddb_server, PddbBlockingScalar, PddbLend, PddbLendMut};
+use crate::path::{Path, PathBuf};
+use crate::sys::time::SystemTime;
+use crate::sys::unsupported;
+
+use super::senres::{self, Senres, SenresMut};
+
+pub use crate::sys_common::fs::exists;
+
+pub struct File {
+    fd: u16,
+    len: u64,
+}
+
+#[derive(Clone)]
+pub struct FileAttr {
+    pub(crate) kind: FileType,
+    pub(crate) len: u64,
+}
+
+pub struct ReadDir {
+    root: PathBuf,
+    entries: Vec<DirEntry>,
+}
+
+pub struct DirEntry {
+    name: String,
+    path: String,
+    // basis: Option<String>,
+    kind: FileType,
+}
+
+#[derive(Clone, Debug)]
+pub struct OpenOptions {
+    create_file: bool,
+    append: bool,
+    truncate: bool,
+    create_new: bool,
+}
+
+#[derive(Copy, Clone, Debug, Default)]
+pub struct FileTimes {}
+
+#[derive(Clone, PartialEq, Eq, Debug)]
+pub struct FilePermissions {}
+
+#[derive(PartialEq, Eq, Debug, Copy, Clone, Hash)]
+pub enum FileType {
+    Basis = 0,
+    Dict = 1,
+    Key = 2,
+    /// This represents both a dict and a key that share the same name
+    DictKey = 3,
+    None = 4,
+    Unknown = 5,
+}
+
+#[derive(Debug)]
+pub struct DirBuilder {}
+
+impl FileAttr {
+    pub fn size(&self) -> u64 {
+        self.len
+    }
+
+    pub fn perm(&self) -> FilePermissions {
+        FilePermissions {}
+    }
+
+    pub fn file_type(&self) -> FileType {
+        self.kind
+    }
+
+    pub fn modified(&self) -> io::Result<SystemTime> {
+        // println!("rust: FileAttr::copy()");
+        unsupported()
+    }
+
+    pub fn accessed(&self) -> io::Result<SystemTime> {
+        // println!("rust: FileAttr::accessed()");
+        unsupported()
+    }
+
+    pub fn created(&self) -> io::Result<SystemTime> {
+        // println!("rust: FileAttr::created()");
+        unsupported()
+    }
+}
+
+impl FilePermissions {
+    pub fn readonly(&self) -> bool {
+        false
+    }
+
+    pub fn set_readonly(&mut self, _readonly: bool) {}
+}
+
+impl FileTimes {
+    pub fn set_accessed(&mut self, _t: SystemTime) {}
+    pub fn set_modified(&mut self, _t: SystemTime) {}
+}
+
+impl FileType {
+    pub fn is_dir(&self) -> bool {
+        let is_dir = match *self {
+            FileType::Basis | FileType::Dict | FileType::DictKey => true,
+            FileType::Key | FileType::Unknown | FileType::None => false,
+        };
+        // println!("rust: {:?} is_dir()? {:?}", self, is_dir);
+        is_dir
+    }
+
+    pub fn is_file(&self) -> bool {
+        let is_file = match *self {
+            FileType::DictKey | FileType::Key => true,
+            FileType::Basis | FileType::Dict | FileType::Unknown | FileType::None => false,
+        };
+        // println!("rust: {:?} is_file()? {:?}", self, is_file);
+        is_file
+    }
+
+    pub fn is_symlink(&self) -> bool {
+        false
+    }
+
+    pub fn is_basis(&self) -> bool {
+        *self == FileType::Basis
+    }
+}
+
+impl Iterator for ReadDir {
+    type Item = io::Result<DirEntry>;
+
+    fn next(&mut self) -> Option<io::Result<DirEntry>> {
+        self.entries.pop().map(|v| Ok(v))
+    }
+}
+
+impl fmt::Debug for ReadDir {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        // This will only be called from std::fs::ReadDir, which will add a "ReadDir()" frame.
+        // Thus the result will be e g 'ReadDir("C:\")'
+        fmt::Debug::fmt(&*self.root, f)
+    }
+}
+
+impl DirEntry {
+    pub fn path(&self) -> PathBuf {
+        PathBuf::from_str(&self.path).unwrap()
+    }
+
+    pub fn file_name(&self) -> OsString {
+        crate::ffi::OsStr::from_bytes(self.name.as_bytes()).to_os_string()
+    }
+
+    pub fn metadata(&self) -> io::Result<FileAttr> {
+        match self.kind {
+            FileType::None | FileType::Unknown => Err(crate::io::Error::new(
+                crate::io::ErrorKind::NotFound,
+                "File or directory does not exist, or is corrupted",
+            )),
+            _ => Ok(FileAttr { kind: self.kind, len: 0 }),
+        }
+    }
+
+    pub fn file_type(&self) -> io::Result<FileType> {
+        Ok(self.kind)
+    }
+}
+
+impl OpenOptions {
+    pub fn new() -> OpenOptions {
+        OpenOptions { create_file: false, truncate: false, append: false, create_new: false }
+    }
+
+    pub fn read(&mut self, _read: bool) {}
+    pub fn write(&mut self, _write: bool) {}
+    pub fn append(&mut self, append: bool) {
+        self.append = append;
+    }
+    pub fn truncate(&mut self, truncate: bool) {
+        self.truncate = truncate;
+    }
+    pub fn create(&mut self, create: bool) {
+        self.create_file = create;
+    }
+    pub fn create_new(&mut self, create_new: bool) {
+        self.create_new = create_new;
+    }
+}
+
+impl File {
+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
+        let mut request = senres::Stack::<4096>::new();
+        let path_as_str = path.as_os_str().to_str().ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+
+        {
+            let mut writer = request.writer(*b"KyOQ").ok_or_else(|| {
+                crate::io::Error::new(
+                    crate::io::ErrorKind::InvalidFilename,
+                    "unable to create request",
+                )
+            })?;
+
+            writer.append(path_as_str);
+            writer.append(opts.create_file);
+            writer.append(false); // create_path
+            writer.append(opts.create_new);
+            writer.append(opts.append);
+            writer.append(opts.truncate);
+            writer.append(0u64); // alloc_hint
+            writer.append::<Option<[u32; 4]>>(None); // callback SID
+        }
+
+        // Make the actual call
+        let (err, _) =
+            request.lend_mut(pddb_server(), PddbLendMut::OpenKeyStd.into()).or_else(|_| {
+                Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+            })?;
+
+        if err != 0 {
+            return Err(crate::io::Error::new(
+                crate::io::ErrorKind::Other,
+                "error occurred when opening file",
+            ));
+        }
+
+        let reader = request.reader(*b"KyOR").ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::Other, "invalid response from server")
+        })?;
+
+        let fd: u16 = reader.try_get_from().or_else(|_| {
+            Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+        })?;
+
+        let len: u64 = reader.try_get_from().or_else(|_| {
+            Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+        })?;
+
+        Ok(File { len, fd })
+    }
+
+    pub fn file_attr(&self) -> io::Result<FileAttr> {
+        Ok(FileAttr { kind: FileType::Key, len: self.len })
+    }
+
+    pub fn fsync(&self) -> io::Result<()> {
+        // println!("rust: File::fsync()");
+        unsupported()
+    }
+
+    pub fn datasync(&self) -> io::Result<()> {
+        // println!("rust: File::datasync()");
+        unsupported()
+    }
+
+    pub fn truncate(&self, _size: u64) -> io::Result<()> {
+        // println!("rust: File::truncate()");
+        unsupported()
+    }
+
+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
+        #[repr(C, align(4096))]
+        struct ReadBuffer {
+            data: [u8; 4096],
+        }
+        let mut buffer = ReadBuffer { data: [0u8; 4096] };
+        let buffer_len = buffer.data.len();
+
+        let (offset, valid) = lend_mut(
+            pddb_server(),
+            PddbLendMut::ReadKeyStd(self.fd).into(),
+            &mut buffer.data,
+            0,
+            buf.len().min(buffer_len),
+        )
+        .map_err(|_| {
+            crate::io::Error::new(crate::io::ErrorKind::Other, "read() encountered an error")
+        })?;
+
+        if offset != 0 {
+            return Err(crate::io::Error::new(
+                crate::io::ErrorKind::Other,
+                "read() encountered an error",
+            ));
+        }
+        let valid = buf.len().min(valid).min(buffer.data.len());
+        let contents = &buffer.data[0..valid];
+        for (src, dest) in contents.iter().zip(buf.iter_mut()) {
+            *dest = *src;
+        }
+        Ok(valid)
+    }
+
+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+        crate::io::default_read_vectored(|buf| self.read(buf), bufs)
+    }
+
+    pub fn is_read_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {
+        crate::io::default_read_buf(|buf| self.read(buf), cursor)
+    }
+
+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
+        #[repr(C, align(4096))]
+        struct ReadBuffer {
+            data: [u8; 4096],
+        }
+        let mut buffer = ReadBuffer { data: [0u8; 4096] };
+
+        let valid = buf.len().min(buffer.data.len());
+        {
+            let contents = &mut buffer.data[0..valid];
+            for (src, dest) in buf.iter().zip(contents.iter_mut()) {
+                *dest = *src;
+            }
+        }
+
+        // This needs to be mutable for now because pddb uses libxous which doesn't
+        // support returning values with non-mutable lends, and we need to get the
+        // "offset" as a return value.
+        let (offset, valid) = lend_mut(
+            pddb_server(),
+            PddbLend::WriteKeyStd(self.fd).into(),
+            &mut buffer.data,
+            0,
+            valid,
+        )
+        .map_err(|_| {
+            crate::io::Error::new(crate::io::ErrorKind::Other, "write() encountered an error")
+        })?;
+
+        if offset == 0 {
+            Ok(valid)
+        } else {
+            Err(crate::io::Error::new(
+                crate::io::ErrorKind::Other,
+                "write operation encountered an error",
+            ))
+        }
+    }
+
+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
+        crate::io::default_write_vectored(|buf| self.write(buf), bufs)
+    }
+
+    pub fn is_write_vectored(&self) -> bool {
+        false
+    }
+
+    pub fn flush(&self) -> io::Result<()> {
+        // println!("rust: File::flush()");
+        unsupported()
+    }
+
+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
+        let result =
+            blocking_scalar(pddb_server(), PddbBlockingScalar::SeekKeyStd(self.fd, pos).into())
+                .map_err(|_| {
+                    crate::io::Error::new(crate::io::ErrorKind::NotSeekable, "error when seeking")
+                })?;
+
+        Ok((result[0] as u64) | ((result[1] as u64) << 32))
+    }
+
+    pub fn duplicate(&self) -> io::Result<File> {
+        unsupported()
+    }
+
+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
+        unsupported()
+    }
+
+    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
+        unsupported()
+    }
+}
+
+impl Drop for File {
+    fn drop(&mut self) {
+        blocking_scalar(pddb_server(), PddbBlockingScalar::CloseKeyStd(self.fd).into()).unwrap();
+    }
+}
+
+impl DirBuilder {
+    pub fn new() -> DirBuilder {
+        DirBuilder {}
+    }
+
+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {
+        let path_as_str = p.as_os_str().to_str().ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+
+        let mut request = super::senres::Stack::<4096>::new();
+
+        let mut writer = request.writer(*b"NuDQ").ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+        writer.append(path_as_str);
+
+        // Make the actual call
+        request.lend_mut(pddb_server(), PddbLendMut::CreateDictStd.into()).or_else(|_| {
+            Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+        })?;
+        Ok(())
+    }
+}
+
+impl fmt::Debug for File {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("File").field("fd", &self.fd).finish()
+    }
+}
+
+pub fn readdir(p: &Path) -> io::Result<ReadDir> {
+    let path_as_str = p.as_os_str().to_str().ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+    })?;
+    let (_basis, _dict) = match crate::sys::path::split_basis_and_dict(path_as_str, || None) {
+        Ok(s) => s,
+        Err(_) => {
+            return Err(crate::io::Error::new(crate::io::ErrorKind::Other, "path was not valid"));
+        }
+    };
+
+    let mut request = super::senres::Stack::<4096>::new();
+
+    // Write the request to the call
+    {
+        let mut writer = request.writer(*b"PthQ").ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+        writer.append(path_as_str);
+    }
+
+    // Make the actual call
+    request.lend_mut(pddb_server(), PddbLendMut::ListPathStd.into()).or_else(|_| {
+        Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+    })?;
+
+    // Read the data back
+    let reader = request.reader(*b"PthR").ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::Other, "invalid response from server")
+    })?;
+
+    let mut entries = vec![];
+    let count = reader.try_get_from::<u32>().unwrap() as usize;
+    for _ in 0..count {
+        let name = reader.try_get_ref_from().unwrap();
+        let kind = match reader.try_get_from::<u8>() {
+            Ok(0) => FileType::Basis,
+            Ok(1) => FileType::Dict,
+            Ok(2) => FileType::Key,
+            Ok(3) => FileType::DictKey,
+            Ok(4) => FileType::None,
+            _ => FileType::Unknown,
+        };
+        let mut path = path_as_str.to_owned();
+        if !path.is_empty() && !path.ends_with(crate::path::MAIN_SEPARATOR) {
+            path.push(crate::path::MAIN_SEPARATOR);
+        }
+        path.push_str(name);
+        entries.push(DirEntry {
+            name: name.to_owned(),
+            path,
+            // basis: basis.map(|m| m.to_owned()),
+            kind,
+        });
+    }
+
+    return Ok(ReadDir { entries, root: p.to_owned() });
+}
+
+pub fn unlink(p: &Path) -> io::Result<()> {
+    let path_as_str = p.as_os_str().to_str().ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+    })?;
+    let mut request = super::senres::Stack::<4096>::new();
+    {
+        let mut writer = request.writer(*b"RmKQ").ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+        writer.append(path_as_str);
+    }
+
+    // Make the actual call
+    let (err, _) =
+        request.lend_mut(pddb_server(), PddbLendMut::DeleteKeyStd.into()).or_else(|_| {
+            Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+        })?;
+
+    if err != 0 {
+        return Err(crate::io::Error::new(crate::io::ErrorKind::Other, "error during operation"));
+    }
+    Ok(())
+}
+
+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {
+    // println!("rust: rename()");
+    unsupported()
+}
+
+pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {
+    // println!("rust: set_perm()");
+    unsupported()
+}
+
+pub fn rmdir(p: &Path) -> io::Result<()> {
+    let path_as_str = p.as_os_str().to_str().ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+    })?;
+
+    let mut request = super::senres::Stack::<4096>::new();
+
+    let mut writer = request.writer(*b"RmDQ").ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+    })?;
+    writer.append(path_as_str);
+
+    // Make the actual call
+    let (err, _) =
+        request.lend_mut(pddb_server(), PddbLendMut::DeleteDictStd.into()).or_else(|_| {
+            Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+        })?;
+    if err != 0 {
+        return Err(crate::io::Error::new(crate::io::ErrorKind::Other, "error during operation"));
+    }
+    Ok(())
+}
+
+pub fn remove_dir_all(path: &Path) -> io::Result<()> {
+    for child in readdir(path)? {
+        let child = child?;
+        let child_type = child.file_type()?;
+        if child_type.is_dir() {
+            remove_dir_all(&child.path())?;
+        } else {
+            unlink(&child.path())?;
+        }
+    }
+    rmdir(path)
+}
+
+pub fn readlink(p: &Path) -> io::Result<PathBuf> {
+    stat(p)?;
+    Err(io::const_io_error!(io::ErrorKind::InvalidInput, "not a symbolic link"))
+}
+
+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
+    // This target doesn't support symlinks
+    unsupported()
+}
+
+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
+    // This target doesn't support links
+    unsupported()
+}
+
+pub fn stat(p: &Path) -> io::Result<FileAttr> {
+    let path_as_str = p.as_os_str().to_str().ok_or_else(|| {
+        crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+    })?;
+    let mut request = super::senres::Stack::<4096>::new();
+
+    // Write the request to the call
+    {
+        let mut writer = request.writer(*b"StaQ").ok_or_else(|| {
+            crate::io::Error::new(crate::io::ErrorKind::InvalidFilename, "invalid path")
+        })?;
+        writer.append(path_as_str);
+    }
+
+    // Make the actual call
+    request.lend_mut(pddb_server(), PddbLendMut::StatPathStd.into()).or_else(|_| {
+        Err(crate::io::Error::new(crate::io::ErrorKind::Other, "unable to query database"))
+    })?;
+
+    // Read the data back
+    let reader = request.reader(*b"StaR").expect("unable to get reader");
+    let kind = match reader.try_get_from::<u8>() {
+        Ok(0) => FileType::Basis,
+        Ok(1) => FileType::Dict,
+        Ok(2) => FileType::Key,
+        Ok(3) => FileType::DictKey,
+        Ok(4) => FileType::None,
+        Ok(5) => FileType::Unknown,
+        _ => FileType::Unknown,
+    };
+
+    match kind {
+        FileType::None | FileType::Unknown => Err(crate::io::Error::new(
+            crate::io::ErrorKind::NotFound,
+            "File or directory does not exist, or is corrupted",
+        )),
+        _ => Ok(FileAttr { kind, len: 0 }),
+    }
+}
+
+pub fn lstat(p: &Path) -> io::Result<FileAttr> {
+    // This target doesn't support symlinks
+    stat(p)
+}
+
+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
+    // println!("rust: canonicalize()");
+    unsupported()
+}
+
+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
+    use crate::fs::File;
+
+    let mut reader = File::open(from)?;
+    let mut writer = File::create(to)?;
+
+    io::copy(&mut reader, &mut writer)
+}
diff --git a/library/std/src/sys/pal/xous/mod.rs b/library/std/src/sys/pal/xous/mod.rs
index b4f122fc4be..c9ac75bb06a 100644
--- a/library/std/src/sys/pal/xous/mod.rs
+++ b/library/std/src/sys/pal/xous/mod.rs
@@ -3,7 +3,6 @@
 pub mod args;
 #[path = "../unsupported/env.rs"]
 pub mod env;
-#[path = "../unsupported/fs.rs"]
 pub mod fs;
 #[path = "../unsupported/io.rs"]
 pub mod io;
-- 
2.34.1

