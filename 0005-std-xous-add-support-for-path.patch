From 8c2468ddc7945a5086322a90521b04a7854ffeac Mon Sep 17 00:00:00 2001
From: Sean Cross <sean@osdyne.com>
Date: Tue, 6 Aug 2024 22:45:31 +0800
Subject: [PATCH 5/7] std: xous: add support for path

Add support for the Xous-specific path implementation.

Signed-off-by: Sean Cross <sean@osdyne.com>
---
 library/std/src/sys/path/mod.rs  |  3 ++
 library/std/src/sys/path/xous.rs | 72 ++++++++++++++++++++++++++++++++
 2 files changed, 75 insertions(+)
 create mode 100644 library/std/src/sys/path/xous.rs

diff --git a/library/std/src/sys/path/mod.rs b/library/std/src/sys/path/mod.rs
index 24a94ec7828..c501416f718 100644
--- a/library/std/src/sys/path/mod.rs
+++ b/library/std/src/sys/path/mod.rs
@@ -11,6 +11,9 @@
     ))] {
         mod unsupported_backslash;
         pub use unsupported_backslash::*;
+    } else if #[cfg(target_os = "xous")] {
+        mod xous;
+        pub use xous::*;
     } else {
         mod unix;
         pub use unix::*;
diff --git a/library/std/src/sys/path/xous.rs b/library/std/src/sys/path/xous.rs
new file mode 100644
index 00000000000..262bfe5985c
--- /dev/null
+++ b/library/std/src/sys/path/xous.rs
@@ -0,0 +1,72 @@
+use crate::ffi::OsStr;
+use crate::io;
+use crate::path::{Path, PathBuf, Prefix};
+
+#[inline]
+pub fn is_sep_byte(b: u8) -> bool {
+    b == b':'
+}
+
+#[inline]
+pub fn is_verbatim_sep(b: u8) -> bool {
+    b == b':'
+}
+
+#[inline]
+pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {
+    None
+}
+
+pub const MAIN_SEP_STR: &str = ":";
+pub const MAIN_SEP: char = ':';
+
+/// Make a POSIX path absolute without changing its semantics.
+pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {
+    Ok(path.to_owned())
+}
+
+/// Split a path into its constituant Basis and Dict, if the path is legal.
+pub(crate) fn split_basis_and_dict<'a, F: Fn() -> Option<&'a str>>(
+    src: &'a str,
+    default: F,
+) -> Result<(Option<&'a str>, Option<&'a str>), ()> {
+    let mut basis = None;
+    let dict;
+    if let Some(src) = src.strip_prefix(crate::path::MAIN_SEPARATOR) {
+        if let Some((maybe_basis, maybe_dict)) = src.split_once(crate::path::MAIN_SEPARATOR) {
+            if !maybe_basis.is_empty() {
+                basis = Some(maybe_basis);
+            } else {
+                basis = default();
+            }
+
+            if maybe_dict.is_empty() {
+                dict = None;
+            } else {
+                dict = Some(maybe_dict);
+            }
+        } else {
+            if !src.is_empty() {
+                basis = Some(src);
+            }
+            dict = None;
+        }
+    } else {
+        if src.is_empty() {
+            return Ok((basis, Some("")));
+        }
+        dict = Some(src);
+    }
+
+    if let Some(basis) = &basis {
+        if basis.ends_with(crate::path::MAIN_SEPARATOR) {
+            return Err(());
+        }
+    }
+    if let Some(dict) = &dict {
+        if dict.ends_with(crate::path::MAIN_SEPARATOR) {
+            return Err(());
+        }
+    }
+    Ok((basis, dict))
+}
-- 
2.40.0.windows.1

